---
title: "Portafolio"
author: "Ortiz Cruz José Gabriel"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 4
    code_folding: show
    #theme: flatly
    theme: journal
  word_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Matrices

## Gaussiana Simple

### Algoritomo que nos ayudara Gaussiana Simple
 
```{r}
gauss_simple <- function(A, b, tolerancia, verbose = FALSE) {
  # 1. Comprobación de errores inicial
  if (!is.matrix(A)) stop("A debe ser una matriz.")
  if (!is.numeric(b)) stop("b debe ser numérico.")
  
  n <- nrow(A)
  
  if (ncol(A) != n) stop("A debe ser cuadrada.")
  if (length(b) != n) stop("La longitud de b debe ser igual al número de filas de A.")
  
  # 2. Creación de la matriz aumentada Ab
  Ab <- cbind(A, b)
  numcols <- ncol(Ab)
  
  # 3. Fase de Eliminación (Conversión a Matriz Triangular Superior)
  for (k in 1:(n - 1)) {
    # Pivote
    pivote <- Ab[k, k]
    
    # Comprobación de pivote casi cero (sin pivoteo)
    if (abs(pivote) < tolerancia) {
      stop(sprintf("Pivote casi cero en fila %d (%.3e). El método sin pivoteo falla.", k, pivote))
    }
    
    # Eliminación para las filas i > k
    if (k + 1 <= n) {
      for (i in (k + 1):n) {
        # Multiplicador
        m <- Ab[i, k] / pivote
        
        # Operación elemental de fila: F_i = F_i - m * F_k
        Ab[i, k:numcols] <- Ab[i, k:numcols] - m * Ab[k, k:numcols]
        
        # Ajuste para evitar errores de coma flotante en la posición eliminada
        if (abs(Ab[i, k]) < tolerancia) Ab[i, k] <- 0
        
        # Salida detallada (si verbose = TRUE)
        if (verbose) {
          cat(sprintf("k=%d, i=%d, m=%.6g\n", k, i, m))
          print(Ab)
        }
      }
    }
  }
  
  # 4. Fase de Sustitución hacia Atrás (Back-Substitution)
  x <- numeric(n)
  
  for (i in n:1) {
    if (i == n) {
      suma <- 0 # El último elemento (x_n) no tiene términos a sumar
    } else {
      # Suma de Ab[i, j] * x[j] para j = i+1 hasta n
      suma <- sum(Ab[i, (i + 1):n] * x[(i + 1):n])
    }
    
    # Despeje x[i]
    x[i] <- (Ab[i, n + 1] - suma) / Ab[i, i]
  }
  
  # 5. Devolver resultados
  # x: vector solución
  # U: Matriz triangular superior (sin la columna aumentada b)
  # Ab: Matriz aumentada final
  list(x = x, U = Ab[, 1:n], Ab = Ab)
}
```

#### Ejercicio 1

```{r}
A <- matrix(c(
  1, -2, 0.5, 
  -2, 5, -1.5,
  -0.2, 1.75, -1), nrow = 3, byrow = TRUE)

# Aseguramos que si sea la Matriz 
print(A)

b <- c(-5, 0, 10)
tolerancia <- 1e-12

res <- gauss_simple(A, b, tolerancia)
res <- gauss_simple(A, b, tolerancia, verbose = TRUE)

# Mostraría el **vector solución** $x$.
res$x
# Mostraría la matriz triangular superior $U$.
res$U
# Mostraría la matriz aumentada final (U|b).
res$Ab
# Mostraría la matriz b, como comprobación.
A %*% res$x
```

#### Ejercicio 2

```{r}
A <- matrix(c(
   3, -1, 0, 6,
   4, 2, -1, -5,
   -5, 1, -3, 0,
   0, 10, -4, 7), nrow = 4, byrow = TRUE)

# Aseguramos que si sea la Matriz 
print(A)

b <- c(2.3, 6.9, -36, -36)
tolerancia <- 1e-12

res <- gauss_simple(A, b, tolerancia)
res <- gauss_simple(A, b, tolerancia, verbose = TRUE)

# Mostraría el **vector solución** $x$.
res$x
# Mostraría la matriz triangular superior $U$.
res$U
# Mostraría la matriz aumentada final (U|b).
res$Ab
# Mostraría la matriz b, como comprobación.
A %*% res$x
```

#### Ejercicio 3

```{r}
A <- matrix(c(
   0.003000, 59.14,
   5.291, -6.130), nrow = 2, byrow = TRUE)

# Aseguramos que si sea la Matriz 
print(A)

b <- c(59.17, 46.78)
tolerancia <- 1e-12

res <- gauss_simple(A, b, tolerancia)
res <- gauss_simple(A, b, tolerancia, verbose = TRUE)

# Mostraría el **vector solución** $x$.
res$x
# Mostraría la matriz triangular superior $U$.
res$U
# Mostraría la matriz aumentada final (U|b).
res$Ab
# Mostraría la matriz b, como comprobación.
A %*% res$x
```

#### Ejercicio 4

```{r}
A <- matrix(c(
   4, 2, 0,
   2, 3, 1,
   0, 1, (5/2)), nrow = 3, byrow = TRUE)

# Aseguramos que si sea la Matriz 
print(A)

b <- c(2, -1, 3)
tolerancia <- 1e-12

res <- gauss_simple(A, b, tolerancia)
res <- gauss_simple(A, b, tolerancia, verbose = TRUE)

# Mostraría el **vector solución** $x$.
res$x
# Mostraría la matriz triangular superior $U$.
res$U
# Mostraría la matriz aumentada final (U|b).
res$Ab
# Mostraría la matriz b, como comprobación.
A %*% res$x
```

#### Ejercicio 5

```{r}
A <- matrix(c(
   3, -0.1, -0.2,
   0.1, 7, -0.3,
   0.3, -0.2, 10), nrow = 3, byrow = TRUE)

# Aseguramos que si sea la Matriz 
print(A)

b <- c(7.85, -19.3, 71.4)
tolerancia <- 1e-12

res <- gauss_simple(A, b, tolerancia)
res <- gauss_simple(A, b, tolerancia, verbose = TRUE)

# Mostraría el **vector solución** $x$.
res$x
# Mostraría la matriz triangular superior $U$.
res$U
# Mostraría la matriz aumentada final (U|b).
res$Ab
# Mostraría la matriz b, como comprobación.
A %*% res$x
```

#### Ejercicio 8

```{r}
A <- matrix(c(
   2, 3, 2, 4,
   4, 10, -4, 0,
   -3, -2, -5, -2,
   -2, 4, 4, -7), nrow = 4, byrow = TRUE)

# Aseguramos que si sea la Matriz 
print(A)

b <- c(4, -8, -4, -1)
tolerancia <- 1e-12

res <- gauss_simple(A, b, tolerancia)
res <- gauss_simple(A, b, tolerancia, verbose = TRUE)

# Mostraría el **vector solución** $x$.
res$x
# Mostraría la matriz triangular superior $U$.
res$U
# Mostraría la matriz aumentada final (U|b).
res$Ab
# Mostraría la matriz b, como comprobación.
A %*% res$x
```

#### Ejercicio 9

```{r}
A <- matrix(c(
   1.33, 5.281, -2.454,
   24.14, -1.21, 5.281,
   -10.123, 6.387, -1), nrow = 3, byrow = TRUE)

# Aseguramos que si sea la Matriz 
print(A)

b <- c(6.414, 113.8, 1)
tolerancia <- 1e-12

res <- gauss_simple(A, b, tolerancia)
res <- gauss_simple(A, b, tolerancia, verbose = TRUE)

# Mostraría el **vector solución** $x$.
res$x
# Mostraría la matriz triangular superior $U$.
res$U
# Mostraría la matriz aumentada final (U|b).
res$Ab
# Mostraría la matriz b, como comprobación.
A %*% res$x
```

#### Ejercicio 10

```{r}
A <- matrix(c(
   2, 3, 2, 4,
   4, 10, -4, 0,
   -3, -2, -5, -2,
   -2, 4, 4, -7), nrow = 4, byrow = TRUE)

# Aseguramos que si sea la Matriz 
print(A)

b <- c(9, -15, 6, 2)
tolerancia <- 1e-12

res <- gauss_simple(A, b, tolerancia)
res <- gauss_simple(A, b, tolerancia, verbose = TRUE)

# Mostraría el **vector solución** $x$.
res$x
# Mostraría la matriz triangular superior $U$.
res$U
# Mostraría la matriz aumentada final (U|b).
res$Ab
# Mostraría la matriz b, como comprobación.
A %*% res$x
```

## Gaussiana con pivoteo parcial

### Algoritomo que nos ayudara Gaussiana con pivoteo parcial

```{r}
gauss_piv_parcial <- function(A, b, tolerancia, verbose = FALSE) {
  
  # VALIDACIONES INICIALES

  if (!is.matrix(A)) stop("A debe ser una matriz.")
  
  n <- nrow(A)
  
  if (ncol(A) != n) stop("A debe ser cuadrada.")
  if (length(b) != n) stop("Dimensiones de b incorrectas.")
  
  # Crear matriz aumentada [A|b]
  Ab <- cbind(A, b)
  
  

  # FASE 1: ELIMINACIÓN HACIA ADELANTE

  for (k in 1:(n-1)) {
    
    # PIVOTEO PARCIAL

    # Selección del pivote (máximo en valor absoluto 
    # en la columna k desde la fila k)
    max_row <- which.max(abs(Ab[k:n, k])) + (k - 1)
    
    # Verificar que el pivote no sea casi cero
    if (abs(Ab[max_row, k]) < tolerancia) {
      stop(sprintf("Pivote casi nulo en columna %d", k))
    }
    
    # Intercambio de filas si es necesario
    if (max_row != k) {
      Ab[c(k, max_row), ] <- Ab[c(max_row, k), ]
      
      if (verbose) {
        cat(sprintf("Intercambio de fila %d con fila %d\n", k, max_row))
        print(Ab)
      }
    }
    
    # ELIMINACIÓN

    for (i in (k + 1):n) {
      # Calcular multiplicador
      m <- Ab[i, k] / Ab[k, k]
      
      # Actualizar fila i
      Ab[i, k:ncol(Ab)] <- Ab[i, k:ncol(Ab)] - m * Ab[k, k:ncol(Ab)]
      
      # Corrección de error numérico
      if (abs(Ab[i, k]) < tolerancia) Ab[i, k] <- 0
      
      if (verbose) {
        cat(sprintf("k=%d, i=%d, m=%.6g\n", k, i, m))
        print(Ab)
      }
    }
  }
  

  # FASE 2: SUSTITUCIÓN HACIA ATRÁS
  
  x <- numeric(n)
  
  for (i in n:1) {
    if (i == n) {
      suma <- 0
    } else {
      suma <- sum(Ab[i, (i + 1):n] * x[(i + 1):n])
    }
    
    x[i] <- (Ab[i, n + 1] - suma) / Ab[i, i]
  }
  
  # RETORNAR RESULTADOS
  
  list(
    x = x,           # Vector solución
    U = Ab[, 1:n],   # Matriz triangular superior
    Ab = Ab          # Matriz aumentada final
  )
}
```

#### Ejercicio 1

```{r}
A <- matrix(c(
   0.4, -1.5, 0.75,
   -0.5, -15, 10, 
   -10, -9, 2.5), nrow = 3, byrow = TRUE)

# Aseguramos que si sea la Matriz 
print(A)

b <- c(-20, -10, 30)
tolerancia <- 1e-12
 
 res <- gauss_piv_parcial(A, b, tolerancia, verbose = TRUE);
 # Mostraría el **vector solución** $x$.
 res$x
 # Verificación del resultado: A * x debería ser igual a b
A %*% res$x
```

#### Ejercicio 3

```{r}
A <- matrix(c(
   0.003000, 59.14,
   5.291, -6.130), nrow = 2, byrow = TRUE)

# Aseguramos que si sea la Matriz 
print(A)

b <- c(59.17, 46.78)
tolerancia <- 1e-12
 
 res <- gauss_piv_parcial(A, b, tolerancia, verbose = TRUE);
 # Mostraría el **vector solución** $x$.
 res$x
 # Verificación del resultado: A * x debería ser igual a b
A %*% res$x
```

#### Ejercicio 5

```{r}
A <- matrix(c(
   0.00031000, 1.000000,
   1.00045534, 1.00034333), nrow = 2, byrow = TRUE)

# Aseguramos que si sea la Matriz 
print(A)

b <- c(3.000000, 7.000)
tolerancia <- 1e-12
 
 res <- gauss_piv_parcial(A, b, tolerancia, verbose = TRUE);
 # Mostraría el **vector solución** $x$.
 res$x
 # Verificación del resultado: A * x debería ser igual a b
A %*% res$x
```